package org.optimizationBenchmarking.utils.io.structured.impl.abstr;

import java.io.OutputStream;
import java.nio.file.Path;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.logging.Logger;

import org.optimizationBenchmarking.utils.io.EArchiveType;
import org.optimizationBenchmarking.utils.io.encoding.StreamEncoding;
import org.optimizationBenchmarking.utils.io.paths.PathUtils;
import org.optimizationBenchmarking.utils.io.structured.spec.IStreamOutputJobBuilder;
import org.optimizationBenchmarking.utils.io.structured.spec.IStreamOutputTool;

/**
 * A tool for generating stream output. The contents generated by this tool
 * are always a single file or stream of data.
 *
 * @param <S>
 *          the source type
 */
public class StreamOutputTool<S> extends FileOutputTool<S> implements
    IStreamOutputTool<S> {

  /** create */
  protected StreamOutputTool() {
    super();
  }

  /** {@inheritDoc} */
  @Override
  final void _checkRawStreams() {
    // well, we can handle raw streams now
  }

  /**
   * Obtain the default name for a plain file to write to if the
   * destination path specifies a directory or ZIP archive
   *
   * @return the default file name
   */
  protected String getDefaultPlainOutputFileName() {
    return "output.file"; //$NON-NLS-1$
  }

  /** {@inheritDoc} */
  @Override
  final void _path(final IOJob job, final S data, final Path path,
      final BasicFileAttributes attributes,
      final StreamEncoding<?, ?> encoding, final EArchiveType archiveType)
      throws Throwable {
    final Path file;
    final _OutputJob outJob;
    final Object oldCur, oldCur2;
    final Logger logger;

    oldCur = job.m_current;
    try {
      job.m_current = path;
      logger = job.getLogger();

      if ((attributes != null) && (attributes.isDirectory())) {
        file = PathUtils.createPathInside(
            path,
            ((archiveType != null) ? //
            (this.getArchiveFallbackFileName() + '.' + archiveType
                .getDefaultSuffix()) : //
                this.getDefaultPlainOutputFileName()));
        if ((logger != null)
            && (logger.isLoggable(IOTool.DEFAULT_LOG_LEVEL))) {
          logger.log(IOTool.DEFAULT_LOG_LEVEL,//
              (((("Path '" + path) + //$NON-NLS-1$
              "' identifies a directory, creating file '") //$NON-NLS-1$
              + file) + "' for output."));//$NON-NLS-1$
        }
      } else {
        file = path;
      }

      oldCur2 = job.m_current;
      try {
        job.m_current = file;
        if (archiveType != null) {
          try (final OutputStream fileOutput = PathUtils
              .openOutputStream(file)) {
            this._stream(job, data, fileOutput, encoding, archiveType);
          }

          outJob = ((_OutputJob) job);
          if (outJob.m_support != null) {
            outJob.m_support.addFile(file, archiveType);
          }
        } else {
          this.file(job, data, file, encoding);
        }
      } finally {
        job.m_current = oldCur2;
      }
    } finally {
      job.m_current = oldCur;
    }
  }

  /**
   * Write the output to a plain file
   *
   * @param job
   *          the job
   * @param data
   *          the data
   * @param file
   *          the file
   * @param encoding
   *          the encoding
   * @throws Throwable
   *           if I/O fails
   */
  protected void file(final IOJob job, final S data, final Path file,
      final StreamEncoding<?, ?> encoding) throws Throwable {
    final Object oldCur;

    oldCur = job.m_current;
    try {
      try (final OutputStream fileOutput = PathUtils
          .openOutputStream(file)) {
        this._stream(job, data, fileOutput, encoding, null);
      }
    } finally {
      job.m_current = oldCur;
    }
  }

  /** {@inheritDoc} */
  @Override
  protected void path(final IOJob job, final S data, final Path path,
      final BasicFileAttributes attributes,
      final StreamEncoding<?, ?> encoding) throws Throwable {
    final Object oldCur;

    oldCur = job.m_current;
    try {
      job.m_current = path;
      this._path(job, data, path, attributes, encoding, null);
    } finally {
      job.m_current = oldCur;
    }
  }

  /** {@inheritDoc} */
  @Override
  final void _stream(final IOJob job, final S data,
      final OutputStream stream, final StreamEncoding<?, ?> encoding,
      final EArchiveType archiveType) throws Throwable {
    final Logger logger;
    String name;

    if (archiveType != null) {
      name = this.getDefaultPlainOutputFileName();
      logger = job.getLogger();
      if ((logger != null)
          && (logger.isLoggable(IOTool.DEFAULT_LOG_LEVEL))) {
        logger.log(IOTool.DEFAULT_LOG_LEVEL,//
            (((("Creating " + archiveType.getName()) + //$NON-NLS-1$
            " output with file '") + name)//$NON-NLS-1$
            + "' as the data (and only) file in the compressed stream.")); //$NON-NLS-1$
      }
      try (final OutputStream output = archiveType.compressStream(stream,
          this.getArchiveFallbackFileName())) {
        this.__stream(job, data, output, encoding);
      }
    } else {
      this.__stream(job, data, stream, encoding);
    }
  }

  /**
   * Store the data element to a stream
   *
   * @param job
   *          the job where logging info can be written
   * @param data
   *          the data to be written
   * @param stream
   *          the stream
   * @param encoding
   *          the encoding
   * @throws Throwable
   *           if I/O fails
   */
  private final void __stream(final IOJob job, final S data,
      final OutputStream stream, final StreamEncoding<?, ?> encoding)
      throws Throwable {
    final Logger logger;
    Class<?> clazz;

    if ((encoding != null) && (encoding != StreamEncoding.UNKNOWN)
        && (encoding != StreamEncoding.TEXT)
        && (encoding != StreamEncoding.BINARY)
        && ((clazz = encoding.getOutputClass()) != null)
        && OutputStream.class.isAssignableFrom(clazz)) {

      logger = job.getLogger();
      if ((logger != null) && (logger.isLoggable(IOTool.FINE_LOG_LEVEL))) {
        logger.log(IOTool.FINE_LOG_LEVEL,//
            ("Using byte stream encoding " + //$NON-NLS-1$
            encoding.name()));
      }
      try (OutputStream encoded = ((OutputStream) (encoding
          .wrapOutputStream(stream)))) {
        this.stream(job, data, encoded, StreamEncoding.UNKNOWN);
      }
    } else {
      this.stream(job, data, stream, encoding);
    }
  }

  /**
   * Store the data element to a stream
   *
   * @param job
   *          the job where logging info can be written
   * @param data
   *          the data to be written
   * @param stream
   *          the stream
   * @param encoding
   *          the encoding
   * @throws Throwable
   *           if I/O fails
   */
  protected void stream(final IOJob job, final S data,
      final OutputStream stream, final StreamEncoding<?, ?> encoding)
      throws Throwable {
    //
  }

  /** {@inheritDoc} */
  @SuppressWarnings({ "unchecked", "rawtypes" })
  @Override
  public IStreamOutputJobBuilder<S> use() {
    this.checkCanUse();
    return new _StreamOutputJobBuilder(this);
  }
}
